//! Request/reply guest module used by the end-to-end test harness.

use anyhow::{Result, anyhow};
use futures::TryStreamExt;
use selium_atlas::{Atlas, Uri};
use selium_switchboard::{Client, Server, Switchboard};
use selium_userland::{entrypoint, schema};
use tracing::info;

/// Flatbuffer bindings generated by the build script.
#[rustfmt::skip]
#[allow(warnings)]
pub mod fbs;

/// Response payload returned to the request/reply client.
#[schema(
    path = "schemas/message.fbs",
    ty = "tests.request_reply.Message",
    binding = "crate::fbs::tests::request_reply::Message"
)]
pub struct Message {
    /// Echoed payload.
    pub msg: String,
}

#[entrypoint]
async fn request_reply_client(ctx: selium_userland::Context) -> Result<()> {
    let switchboard = ctx.require::<Switchboard>().await;
    let atlas = ctx.require::<Atlas>().await;

    let server_channel: u32 = atlas
        .get(&Uri::parse("sel://moo/cow").unwrap())
        .await?
        .ok_or(anyhow!("server channel not found"))?
        .try_into()
        .unwrap();

    let mut client = Client::create(&switchboard).await?;
    client.connect(&switchboard, server_channel).await?;

    let msg = Message::new("ping".to_string());
    info!(request_channel = server_channel, "sending ping");

    let reply: Message = client.request(msg).await?;
    info!(reply = reply.msg, "received echo reply");

    Ok(())
}

#[entrypoint]
async fn request_reply_server(ctx: selium_userland::Context) -> Result<()> {
    let switchboard = ctx.require::<Switchboard>().await;
    let atlas = ctx.require::<Atlas>().await;

    let server: Server<Message, Message> = Server::create(&switchboard).await?;
    atlas
        .insert(
            Uri::parse("sel://moo/cow").unwrap(),
            server.endpoint_id() as u64,
        )
        .await?;

    server
        .try_for_each(async |req| {
            info!(msg = req.request().msg, "received request");

            req.reply(Message { msg: "pong".into() }).await
        })
        .await?;

    Ok(())
}
